帮我用Flutter写一个字符串编辑器,对字符串进行编辑
将字符串显示未一个二维map,通过\n字符换行
光标可以随意点击任意一个文字,然后修改它

------------------------------
创建一个字符串编辑器在Flutter中并不复杂。下面是一个基本示例，它将字符串显示为二维map的形式，并且支持通过光标点击进行修改。这个示例可以根据需要进行扩展和修改。

### 示例代码

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(StringEditor());
}

class StringEditor extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'String Editor',
      home: EditorScreen(),
    );
  }
}

class EditorScreen extends StatefulWidget {
  @override
  _EditorScreenState createState() => _EditorScreenState();
}

class _EditorScreenState extends State<EditorScreen> {
  String text = "Hello\nWorld\nThis is a simple editor!";
  List<List<String>> displayText = [];

  @override
  void initState() {
    super.initState();
    _parseText();
  }

  void _parseText() {
    displayText = text.split('\n').map((line) => line.split('')).toList();
  }

  void _updateChar(int line, int column, String newChar) {
    setState(() {
      displayText[line][column] = newChar;
      text = displayText.map((line) => line.join()).join('\n');
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('String Editor'),
      ),
      body: Column(
        children: [
          Expanded(
            child: GridView.builder(
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: displayText[0].length,
              ),
              itemCount: displayText.length * displayText[0].length,
              itemBuilder: (context, index) {
                int line = index ~/ displayText[0].length;
                int column = index % displayText[0].length;
                return GestureDetector(
                  onTap: () => _showEditDialog(line, column),
                  child: Container(
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.black),
                    ),
                    child: Text(
                      displayText[line][column],
                      style: TextStyle(fontSize: 24),
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  void _showEditDialog(int line, int column) {
    TextEditingController controller = TextEditingController(text: displayText[line][column]);

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text('Edit Character'),
          content: TextField(
            controller: controller,
            maxLength: 1,
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () {
                String newChar = controller.text;
                if (newChar.isNotEmpty) {
                  _updateChar(line, column, newChar);
                }
                Navigator.of(context).pop();
              },
              child: Text('OK'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text('Cancel'),
            ),
          ],
        );
      },
    );
  }
}
```

### 解释

1. **结构**:
   - 主应用通过 `StringEditor` 类启动，显示 `EditorScreen`。
   - `EditorScreen` 中维护一个字符串 `text`，并将其分解为二维 `displayText`。

2. **显示内容**:
   - 使用 `GridView.builder` 显示字符，通过 `GestureDetector` 响应点击事件。

3. **编辑功能**:
   - 点击字符时会弹出一个对话框，允许用户输入新字符，并通过 `_updateChar` 方法更新相应的字符。

### 使用方法

1. 将上面的代码复制到一个新的 Flutter 项目中。
2. 运行应用，即可看到简单的字符串编辑界面。
3. 点击任意字符进行编辑。

这个示例是基础实现，你可以根据自己的需求添加更多的功能和完善的用户体验。
------------------------------
我需要声明两个变量来保存光标位置,使用键盘上下左右方向键移动光标,键盘的字符键(abcd等)来进行输入,当输入完一个字符时,光标自动跳转到下一个字符,请优化下代码,提高编辑的速度


------------------------------
好的，我们可以优化代码，使其支持使用键盘的方向键移动光标，并且在输入字符后自动移动光标到下一个位置。为了实现这个功能，您需要处理键盘事件并更新光标位置。以下是经过优化的代码示例：

### 优化后的示例代码

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void main() {
  runApp(StringEditor());
}

class StringEditor extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'String Editor',
      home: EditorScreen(),
    );
  }
}

class EditorScreen extends StatefulWidget {
  @override
  _EditorScreenState createState() => _EditorScreenState();
}

class _EditorScreenState extends State<EditorScreen> {
  String text = "Hello\nWorld\nThis is a simple editor!";
  List<List<String>> displayText = [];
  int cursorRow = 0;
  int cursorColumn = 0;

  @override
  void initState() {
    super.initState();
    _parseText();
  }

  void _parseText() {
    displayText = text.split('\n').map((line) => line.split('')).toList();
  }

  void _updateChar(int row, int col, String newChar) {
    if (newChar.isEmpty) return;

    setState(() {
      displayText[row][col] = newChar;
      text = displayText.map((line) => line.join()).join('\n');
      _moveCursorForward();
    });
  }

  void _moveCursorForward() {
    cursorColumn++;
    if (cursorColumn >= displayText[cursorRow].length) {
      cursorColumn = 0;
      cursorRow = (cursorRow + 1) % displayText.length;
    }
  }

  void _moveCursor(int deltaRow, int deltaColumn) {
    setState(() {
      cursorRow = (cursorRow + deltaRow).clamp(0, displayText.length - 1);
      cursorColumn = (cursorColumn + deltaColumn).clamp(0, displayText[cursorRow].length - 1);
    });
  }

  void _handleKeyPress(RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      if (event.logicalKey == LogicalKeyboardKey.arrowUp) {
        _moveCursor(-1, 0);
      } else if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
        _moveCursor(1, 0);
      } else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
        _moveCursor(0, -1);
      } else if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
        _moveCursor(0, 1);
      } else if (event.logicalKey == LogicalKeyboardKey.backspace) {
        _updateChar(cursorRow, cursorColumn, '');
      } else if (event.logicalKey.character != null && event.logicalKey.character!.length == 1) {
        _updateChar(cursorRow, cursorColumn, event.logicalKey.character!);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Focus(
      autofocus: true,
      onKey: (FocusNode node, RawKeyEvent event) {
        _handleKeyPress(event);
        return KeyEventResult.handled;
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text('String Editor'),
        ),
        body: Column(
          children: [
            Expanded(
              child: GridView.builder(
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: displayText[0].length,
                ),
                itemCount: displayText.length * displayText[0].length,
                itemBuilder: (context, index) {
                  int line = index ~/ displayText[0].length;
                  int column = index % displayText[0].length;
                  bool isCursor = (line == cursorRow && column == cursorColumn);
                  return Container(
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      border: Border.all(color: isCursor ? Colors.blue : Colors.black),
                    ),
                    child: Text(
                      displayText[line][column],
                      style: TextStyle(fontSize: 24, fontWeight: isCursor ? FontWeight.bold : FontWeight.normal),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

### 代码中增加的功能

1. **光标位置变量**:
   - 使用`cursorRow`和`cursorColumn`变量存储光标的当前行和列的位置。

2. **键盘事件处理**:
   - 通过`onKey`事件处理方法捕捉键盘输入。
   - 使用方向键（上下左右）移动光标。
   - 允许字符输入，输入一个字符后光标自动移动到下一个位置。
   - 允许删除字符（使用 `Backspace` 键）。

3. **光标高亮**:
   - 在显示的字符中为光标位置添加蓝色边框，以及调整字体加粗以突出显示光标。

### 使用说明

1. 运行应用程序后，可以使用方向键来移动光标；
2. 输入字符时，光标会自动移到下一个位置；
3. 通过 `Backspace` 键删除字符。

这个优化后的版本提高了编辑的速度，并支持更流畅的用户体验。您可以根据需求进一步修改和扩展功能！
------------------------------

flutter编译报错:
The getter 'character' isn't defined for the type 'LogicalKeyboardKey'.
