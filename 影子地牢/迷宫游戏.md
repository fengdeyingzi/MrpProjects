将以下代码转换为C语言控制台程序,使用c99标准
```
class Ball {
	private int x;//横坐标
	private int y;//纵坐标
	private Color color;//小球颜色
	public Ball(int x,int y) {
		setX(x);
		setY(y);
		setColor(Color.GREEN);
	}

	public int getX() {
		return x;
	}

	public void setX(int x) {
		this.x = x;
	}

	public int getY() {
		return y;
	}

	public int setY(int y) {
		this.y = y;
		return y;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}
	
}

abstract class AbstractCreateMaze {
	// 验证横纵坐标是否超界
	protected boolean isOutofBorder(int x, int y, int colNumber, int rowNumber) {
		if ((x == 0 && y == 1) || (x == colNumber + 1 && y == rowNumber))
			return false;
		else
			return (x > colNumber || y > rowNumber || x < 1 || y < 1) ? true : false;
	}

	abstract void createMaze(Lattice[][] mazeLattice, int colNumber, int rowNumber);
}

class DepthFirstSearchCreateMaze extends AbstractCreateMaze {

	// 随机选择一个p点未访问的相邻迷宫单元 ,并移除两者之间的墙，为createMaze()函数调用
	protected Point ArroundPoint(Lattice[][] mazeLattice, Point p, Stack<Point> s, Random rand, int colNumber,
			int rowNumber) {
		final int[] arroundPoint = { -2, 0, 2, 0, -2 };// 一个点周围四个点的坐标变化，顺序为左上右下
		int r = rand.nextInt(4);
		for (int i = 0; i < 4; ++i) {
			int j = r % 4;
			int x = p.x + arroundPoint[j];
			int y = p.y + arroundPoint[j + 1];
			++r;
			if (!isOutofBorder(x, y, colNumber, rowNumber) && !mazeLattice[y][x].isPassable()) {
				mazeLattice[y][x].setPassable(true);
				mazeLattice[p.y + arroundPoint[j + 1] / 2][p.x + arroundPoint[j] / 2].setPassable(true);
				return new Point(x, y);
			}
		}
		return null;
	}

	@Override
	public void createMaze(Lattice[][] mazeLattice, int colNumber, int rowNumber) {
		// TODO Auto-generated method stub
		Random rand = new Random();
		Point currentPoint = new Point(2 * rand.nextInt(colNumber / 2) + 1, 2 * rand.nextInt(rowNumber / 2) + 1);
		mazeLattice[currentPoint.y][currentPoint.x].setPassable(true);
		Stack<Point> pathStack = new Stack<Point>();
		pathStack.push(currentPoint);
		currentPoint = ArroundPoint(mazeLattice, currentPoint, pathStack, rand, colNumber, rowNumber);
		while (true) {
			Point p = ArroundPoint(mazeLattice, currentPoint, pathStack, rand, colNumber, rowNumber);
			if (p != null) {
				pathStack.push(currentPoint);
				currentPoint = p;
			} else if (!pathStack.isEmpty())
				currentPoint = pathStack.pop();
			else
				break;
		}
	}
}


class Lattice {
	private boolean Passable;// 小球是否能通过
	private Point Father;//是否遍历过
	public Lattice() {
		setPassable(false);
		setFather(null);
	}

	public boolean isPassable() {
		return Passable;
	}

	public void setPassable(boolean isPassable) {
		this.Passable = isPassable;
	}

	/**
	 * @return the father
	 */
	public Point getFather() {
		return Father;
	}

	/**
	 * @param father the father to set
	 */
	public void setFather(Point father) {
		Father = father;
	}
}

package maze;

import java.applet.Applet;
import java.applet.AudioClip;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.Point;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.util.Stack;

import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.EtchedBorder;

class Maze extends JPanel {
	private Point entrance = null;
	private Point exit = null;
	private int rowNumber;// 行数
	private int colNumber;// 列数
	private int LatticeWidth;// 格子的宽度
	private Ball ball;
	private Lattice[][] mazeLattice;
	private boolean startTiming = false;
	private JPanel panel = new JPanel();
	private JTextField timeText = new Timers(), stepNumberText = new JTextField("0");
	private boolean computerDo = false;
	private Thread thread = null;
	private Thread audioThread = null;
	private int stepNmber;
	private static final char DepthFirstSearchSolveMaze = 0;
	private static final char BreadthFirstSearchSolveMaze = 1;
	private char solveMaze = DepthFirstSearchSolveMaze;
	private static final char DepthFirstSearchCreateMaze = 0;
	private static final char RandomizedPrimCreateMaze = 1;
	private static final char RecursiveDivisionCreateMaze = 2;
	private char createMaze = DepthFirstSearchCreateMaze;
	private boolean promptSolveMaze = false;

	public Maze(int row, int col) {
		this.setRowNumber(row);
		this.setColNumber(col);
		this.LatticeWidth = 15;
		mazeLattice = new Lattice[getRowNumber() + 2][getColNumber() + 2];
		setLayout(new BorderLayout(0, 0));
		getTimeText().setForeground(Color.BLUE);
		getTimeText().setFont(new Font("宋体", Font.PLAIN, 14));
		getTimeText().setHorizontalAlignment(JTextField.CENTER);
		stepNumberText.setEnabled(false);
		getStepNumberText().setForeground(Color.BLUE);
		getStepNumberText().setFont(new Font("宋体", Font.PLAIN, 14));
		getStepNumberText().setHorizontalAlignment(JTextField.CENTER);
		Label timeLabel = new Label("Time:"), stepLabel = new Label("StepNumber:");
		timeLabel.setAlignment(Label.RIGHT);
		stepLabel.setAlignment(Label.RIGHT);
		panel.setLayout(new GridLayout(1, 4));
		add(panel, BorderLayout.NORTH);
		panel.add(timeLabel);
		panel.add(getTimeText());
		panel.add(stepLabel);
		panel.add(getStepNumberText());
		panel.setBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null));
		this.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (!isComputerDo()) {
					requestFocus();
				}
			}
		});
		setKeyListener();
		createMaze();
	}

	public void init() {
		mazeLattice = new Lattice[getRowNumber() + 2][getColNumber() + 2];
		setPromptSolveMaze(false);
		setComputerDo(false);
		setThreadStop();
		resetStepNumber();
		resetTimer();
		for (int i = 1; i < getRowNumber() + 1; ++i)
			for (int j = 1; j < getColNumber() + 1; ++j) {
				mazeLattice[i][j] = new Lattice();
			}
		for (int i = 0; i < getRowNumber() + 2; ++i) {
			mazeLattice[i][0] = new Lattice();
			mazeLattice[i][getColNumber() + 1] = new Lattice();
		}
		for (int j = 0; j < getColNumber() + 2; ++j) {
			mazeLattice[0][j] = new Lattice();
			mazeLattice[getRowNumber() + 1][j] = new Lattice();
		}
		ball = new Ball(0, 1);
		setEntrance(new Point(0, 1));
		setExit(new Point(getColNumber() + 1, getRowNumber()));
		mazeLattice[getEntrance().y][getEntrance().x].setPassable(true);
		mazeLattice[getExit().y][getExit().x].setPassable(true);
	}

	// 是否已经走出迷宫
	public boolean isWin() {
		if (getExit().x == ball.getX() && getExit().y == ball.getY()) {
			return true;
		}
		return false;
	}

	// 如果已经走出迷宫即跳出游戏结束对话框
	private void GameOverMessage() {
		((Timers) getTimeText()).stop();
		try {
			// 读取当前java工程项目下的yy.wav文件
			File file1 = new File("media//win.wav");
			AudioClip sound = Applet.newAudioClip(file1.toURI().toURL());
			sound.play();
		} catch (Exception e) {
			e.printStackTrace();
		}
		JOptionPane.showMessageDialog(null,
				"Congratulations on getting out of the maze!\n" + "Time you have used to go out of the maze is: "
						+ timeText.getText() + "\nThe number of the steps you have used to go out of the maze is: "
						+ stepNmber,
				"GameOver", JOptionPane.INFORMATION_MESSAGE);
	}

	// 验证横纵坐标是否超界
	private boolean isOutofBorder(int x, int y) {
		if ((x == 0 && y == 1) || (x == getColNumber() + 1 && y == getRowNumber()))
			return false;
		else
			return (x > getColNumber() || y > getRowNumber() || x < 1 || y < 1) ? true : false;
	}

	//打印
	void paint(){
		StringBuilder builder = new StringBuilder();
		for (int iy = 0; iy < getRowNumber() + 2; ++iy) {


			for (int ix = 0; ix < getColNumber() + 2; ++ix) {
				if(iy==1 && ix==0){
					builder.append("s");
				}
				else if(iy==getRowNumber() && ix==getColNumber()+1){
					builder.append("e");
				}
				else if (mazeLattice[iy][ix].isPassable()) {
					builder.append(" ");
				} else {
					builder.append("*");
				}
			}
			builder.append("\r\n");
		}
		System.out.println(builder.toString());
	}

	// 绘制迷宫
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < getRowNumber() + 2; ++i)
			for (int j = 0; j < getColNumber() + 2; ++j) {
				g.drawRect((j + 1) * LatticeWidth, (i + 1) * LatticeWidth + 30, LatticeWidth, LatticeWidth);
				if (mazeLattice[i][j].isPassable())
					g.setColor(Color.WHITE);
				else
					g.setColor(Color.BLACK);
				g.fillRect((j + 1) * LatticeWidth, (i + 1) * LatticeWidth + 30, LatticeWidth, LatticeWidth);
			}
		g.setColor(Color.RED);//出口
		g.fillRect((getColNumber() + 2) * LatticeWidth, (getRowNumber() + 1) * LatticeWidth + 30, LatticeWidth,
				LatticeWidth);
		g.setColor(ball.getColor());
		g.drawOval((ball.getX() + 1) * LatticeWidth, (ball.getY() + 1) * LatticeWidth + 30, LatticeWidth, LatticeWidth);
		g.fillOval((ball.getX() + 1) * LatticeWidth, (ball.getY() + 1) * LatticeWidth + 30, LatticeWidth, LatticeWidth);
		if (isPromptSolveMaze()) {
			Stack<Point> pathStack = promptsolveMaze();
			g.setColor(Color.GREEN);//入口
			Point start = pathStack.pop();
			while (!pathStack.isEmpty()) {
				Point end = pathStack.pop();
				Graphics2D g2 = (Graphics2D) g;
				g2.setStroke(new BasicStroke(3.0f));
				g2.drawLine((int) (start.getX() + 1) * LatticeWidth + LatticeWidth / 2,
						(int) (start.getY() + 1) * LatticeWidth + 30 + LatticeWidth / 2,
						(int) (end.getX() + 1) * LatticeWidth + LatticeWidth / 2,
						(int) (end.getY() + 1) * LatticeWidth + 30 + LatticeWidth / 2);
				start = end;
			}
		}
	}

	// 设置键盘监听器
	synchronized private void move(int c) {
		int tx = ball.getX(), ty = ball.getY();
		switch (c) {
		case KeyEvent.VK_LEFT:
			--tx;
			break;
		case KeyEvent.VK_RIGHT:
			++tx;
			break;
		case KeyEvent.VK_UP:
			--ty;
			break;
		case KeyEvent.VK_DOWN:
			++ty;
			break;
		case KeyEvent.VK_ESCAPE:
			System.exit(0);
			break;
		default:
			// 防止按键盘上其他键仍然产生键盘音效、使计步器递增
			tx = 0;
			ty = 0;
			break;
		}
		if (!isOutofBorder(tx, ty) && mazeLattice[ty][tx].isPassable()) {
			try {
				File file1 = new File("media//keyPressed.wav");
				AudioClip sound = Applet.newAudioClip(file1.toURI().toURL());
				sound.play();
			} catch (Exception e) {
				e.printStackTrace();
			}
			ball.setX(tx);
			ball.setY(ty);
			++stepNmber;
			stepNumberText.setText(Integer.toString(stepNmber));
			if (!isStartTiming()) {
				setStartTiming(!isStartTiming());
				((Timers) getTimeText()).start();
			}
		}

	}

	private void setKeyListener() {
		this.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if (!isWin()) {
					int c = e.getKeyCode();
					move(c);
					repaint();
					if (isWin() && !isComputerDo())
						GameOverMessage();
				}
			}
		});
	}

	// 将计时器归零
	public void resetTimer() {
		setStartTiming(false);
		getTimeText().setText("00:00:00");
		((Timers) timeText).restart();
	}

	// 将计步器归零
	public void resetStepNumber() {
		setStepNmber(0);
		stepNumberText.setText(Integer.toString(stepNmber));
	}

	// 设置小球的位置
	public void setBallPosition(Point p) {
		ball.setX(p.x);
		ball.setY(p.y);
		repaint();
	}

	// 建立一个迷宫
	public void createMaze() {
		init();
		AbstractCreateMaze c = null;
		if (getCreateMaze() == DepthFirstSearchCreateMaze)
			c = new DepthFirstSearchCreateMaze();
		else if (getCreateMaze() == RandomizedPrimCreateMaze)
			c = new RandomizedPrimCreateMaze();
		else if (getCreateMaze() == RecursiveDivisionCreateMaze)
			c = new RecursiveDivisionCreateMaze();
		c.createMaze(mazeLattice, getColNumber(), getRowNumber());
		repaint();
	}

	// 找出走出迷宫的路径
	private Stack<Point> solveMaze(Point p) {
		AbstractSolveMaze a = null;
		if (getSolveMaze() == BreadthFirstSearchSolveMaze)
			a = new BreadthFirstSearchSolveMaze();
		else if (getSolveMaze() == DepthFirstSearchSolveMaze)
			a = new DepthFirstSearchSolveMaze();
		return a.solveMaze(mazeLattice, p, getExit(), getColNumber(), getRowNumber());
	}

	// 找出小球位于给定位置时走出迷宫的路径
	private Stack<Point> promptsolveMaze() {
		AbstractSolveMaze a = null;
		if (getSolveMaze() == BreadthFirstSearchSolveMaze)
			a = new BreadthFirstSearchSolveMaze();
		else if (getSolveMaze() == DepthFirstSearchSolveMaze)
			a = new DepthFirstSearchSolveMaze();
		return a.solveMaze(mazeLattice, new Point(ball.getX(), ball.getY()), getExit(), getColNumber(), getRowNumber());
	}

	// 将处于给定位置的小球走出迷宫的路径显示在迷宫上显示给定时间长，仅为computerSolveMazeForBallPosition()调用
	private void computerSolveMazeForBallPositionForTime(int time) {
		if (getThread() == null)
			setThread(new Thread() {
				@Override
				public void run() {
					while (!isInterrupted())
						try {
							setPromptSolveMaze(true);
							repaint();
							Thread.sleep(time);
							setPromptSolveMaze(false);
							repaint();
							setThreadStop();
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							break;
						}
				}
			});
		getThread().start();
	}

	// 以time时间显示处于给定位置小球走出迷宫的路径
	public boolean computerSolveMazeForBallPosition() {
		setThreadStop();
		((Timers) getTimeText()).stop();
		int time = 0;
		Object[] selections = { "forever", "10s", "5s", "3s", "1s" };
		Object select = JOptionPane.showInputDialog(null, "Please select the speed of which the ball runs",
				"Jiang's Maze", JOptionPane.INFORMATION_MESSAGE, null, selections, selections[2]);
		if (select != null) {
			switch ((String) select) {
			case "forever":
				time = 2000000000;
				break;
			case "10s":
				time = 10000;
				break;
			case "5s":
				time = 5000;
				break;
			case "3s":
				time = 3000;
				break;
			case "1s":
				time = 1000;
				break;
			default:
				break;
			}
			computerSolveMazeForBallPositionForTime(time);
			((Timers) getTimeText()).proceed();
			return true;
		} else
			return false;
	}

	// 以speed速度由计算机将处于初始位置的小球走出迷宫，仅为computerSolveMaze()函数调用
	private void computerSolveMazeForSpeed(int speed) {
		setComputerDo(true);
		Point p = null;
		if (isWin())
			p = getEntrance();
		else
			p = new Point(ball.getX(), ball.getY());
		Stack<Point> stack = solveMaze(p);
		resetTimer();
		resetStepNumber();
		if (getThread() == null)
			setThread(new Thread() {
				@Override
				public void run() {
					while (!isInterrupted())
						try {
							while (!stack.isEmpty()) {
								Point p = stack.pop();
								setBallPosition(p);
								++stepNmber;
								stepNumberText.setText(Integer.toString(stepNmber));
								Thread.sleep(speed);
							}
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							break;
						}
				}
			});
		getThread().start();
	}

	// 由计算机将处于初始位置的小球走出迷宫
	public boolean computerSolveMaze() {
		int speed = 0;
		setThreadStop();
		Object[] selections = { "lower seed", "low speed", "medium speed", "high speed", "higher speed" };
		Object select = JOptionPane.showInputDialog(null, "Please select the speed of which the ball runs",
				"Jiang's Maze", JOptionPane.INFORMATION_MESSAGE, null, selections, selections[2]);
		if (select != null) {
			switch ((String) select) {
			case "lower seed":
				speed = 400;
				break;
			case "low speed":
				speed = 300;
				break;
			case "medium speed":
				speed = 200;
				break;
			case "high speed":
				speed = 100;
				break;
			case "higher speed":
				speed = 20;
				break;
			default:
				break;
			}
			computerSolveMazeForSpeed(speed);
			return true;
		} else
			return false;
	}

	public int getLatticeWidth() {
		return LatticeWidth;
	}

	public void setLatticeWidth(int latticeWidth) {
		LatticeWidth = latticeWidth;
	}

	public JTextField getTimeText() {
		return timeText;
	}

	/**
	 * @return the startTiming
	 */
	public boolean isStartTiming() {
		return startTiming;
	}

	/**
	 * @param startTiming the startTiming to set
	 */
	public void setStartTiming(boolean startTiming) {
		this.startTiming = startTiming;
	}

	/**
	 * @return the entrance
	 */
	public Point getEntrance() {
		return entrance;
	}

	/**
	 * @param entrance the entrance to set
	 */
	public void setEntrance(Point entrance) {
		this.entrance = entrance;
	}

	/**
	 * @return the exit
	 */
	public Point getExit() {
		return exit;
	}

	/**
	 * @param exit the exit to set
	 */
	private void setExit(Point exit) {
		this.exit = exit;
	}

	/**
	 * @return the computerDo
	 */
	public boolean isComputerDo() {
		return computerDo;
	}

	/**
	 * @param computerDo the computerDo to set
	 */
	public void setComputerDo(boolean computerDo) {
		this.computerDo = computerDo;
	}

	/**
	 * @return the thread
	 */
	public Thread getThread() {
		return thread;
	}

	/**
	 * @param thread the thread to set
	 */
	private void setThread(Thread thread) {
		this.thread = thread;
	}

	public void setThreadStop() {
		if (getThread() != null) {
			if (isPromptSolveMaze())
				setPromptSolveMaze(false);
			thread.interrupt();
			setThread(null);
		}
	}

	/**
	 * @return the stepNumberText
	 */
	public JTextField getStepNumberText() {
		return stepNumberText;
	}

	/**
	 * @return the stepNmber
	 */
	public int getStepNmber() {
		return stepNmber;
	}

	/**
	 * @param stepNmber the stepNmber to set
	 */
	public void setStepNmber(int stepNmber) {
		this.stepNmber = stepNmber;
	}

	/**
	 * @return the rowNumber
	 */
	public int getRowNumber() {
		return rowNumber;
	}

	/**
	 * @param rowNumber the rowNumber to set
	 */
	public void setRowNumber(int rowNumber) {
		this.rowNumber = rowNumber;
	}

	/**
	 * @return the colNumber
	 */
	public int getColNumber() {
		return colNumber;
	}

	/**
	 * @param colNumber the colNumber to set
	 */
	public void setColNumber(int colNumber) {
		this.colNumber = colNumber;
	}

	/**
	 * @return the solveMaze
	 */
	public char getSolveMaze() {
		return solveMaze;
	}

	/**
	 * @param solveMaze the solveMaze to set
	 */
	public void setSolveMaze(char solveMaze) {
		this.solveMaze = solveMaze;
	}

	/**
	 * @return the createMaze
	 */
	public char getCreateMaze() {
		return createMaze;
	}

	/**
	 * @param createMaze the createMaze to set
	 */
	public void setCreateMaze(char createMaze) {
		this.createMaze = createMaze;
	}

	/**
	 * @return the promptSolveMaze
	 */
	public boolean isPromptSolveMaze() {
		return promptSolveMaze;
	}

	/**
	 * @param promptSolveMaze the promptSolveMaze to set
	 */
	public void setPromptSolveMaze(boolean promptSolveMaze) {
		this.promptSolveMaze = promptSolveMaze;
	}

	/**
	 * @return the audioThread
	 */
	private Thread getAudioThread() {
		return audioThread;
	}

	/**
	 * @param audioThread the audioThread to set
	 */
	private void setAudioThread(Thread audioThread) {
		this.audioThread = audioThread;
	}

	public void setAudioThreadStart() {
		if (getAudioThread() == null) {
			setAudioThread(new Thread() {
				@Override
				@SuppressWarnings("restriction")
				// private AudioStream as = null;

				// @SuppressWarnings("restriction")
				public void run() {
					AudioClip sound = null;
					while (!isInterrupted())
						try {
							// 读取当前java工程项目下的yy.wav文件
							File file1 = new File("media//background.wav");
							sound = Applet.newAudioClip(file1.toURI().toURL());
							sound.play();
							Thread.sleep(24000);
						} catch (Exception e) {
							break;
						}
					sound.stop();
				}
			});
			getAudioThread().start();
		}
	}

	public void setAudioThreadStop() {
		if (getAudioThread() != null) {
			getAudioThread().interrupt();
			setAudioThread(null);
		}
	}
}

package maze;

import javax.swing.*;
import java.awt.*;
import java.util.Stack;

public class MazeConsoleMain {
    int col = 10;
    int row = 10;
    final char DepthFirstSearchSolveMaze = 0;
    final char BreadthFirstSearchSolveMaze = 1;
    char solveMaze = 0;
    final char DepthFirstSearchCreateMaze = 0;
    final char RandomizedPrimCreateMaze = 1;
    final char RecursiveDivisionCreateMaze = 2;
    char createMaze = 0;


    Maze maze;
    boolean isPause = false;
    boolean bgmStart = true;

    /**
     * @return the isPause
     */
    public boolean isPause() {
        return isPause;
    }

    /**
     * @param isPause the isPause to set
     */
    public void setPause(boolean isPause) {
        this.isPause = isPause;
    }

    /**
     * @return the solveMaze
     */
    public char getSolveMaze() {
        return solveMaze;
    }

    /**
     * @param solveMaze the solveMaze to set
     */
    public void setSolveMaze(char solveMaze) {
        this.solveMaze = solveMaze;
    }

    /**
     * @return the createMaze
     */
    public char getCreateMaze() {
        return createMaze;
    }

    /**
     * @param createMaze the createMaze to set
     */
    public void setCreateMaze(char createMaze) {
        this.createMaze = createMaze;
    }

    /**
     * @return the bgmStart
     */
    public boolean isBgmStart() {
        return bgmStart;
    }

    /**
     * @param bgmStart the bgmStart to set
     */
    public void setBgmStart(boolean bgmStart) {
        this.bgmStart = bgmStart;
    }



    void go(){
        maze = new Maze(row, col);
        if (getSolveMaze() != maze.getSolveMaze())
            maze.setSolveMaze(getSolveMaze());
        maze.setPromptSolveMaze(false);


        if (maze.getColNumber() == col && maze.getRowNumber() == row) {
            if (getCreateMaze() != maze.getCreateMaze()) {
                maze.setCreateMaze(getCreateMaze());
                maze.createMaze();
            } else {
                maze.setComputerDo(false);
                maze.resetStepNumber();
                maze.resetTimer();
                maze.setThreadStop();
                maze.setBallPosition(maze.getEntrance());
            }
            maze.requestFocus();
            maze.repaint();
            maze.paint();
        } else {
            maze.setColNumber(col);
            maze.setRowNumber(row);
            if (getCreateMaze() != maze.getCreateMaze()) {
                maze.setCreateMaze(getCreateMaze());
            }
            maze.createMaze();
            maze.requestFocus();
            maze.paint();
        }
    }

    public static void main(String[] args) {
        MazeConsoleMain mazeConsoleMain = new MazeConsoleMain();
        mazeConsoleMain.go();

    }
}



```
------------------------------
下面是将提供的Java代码转换为C语言控制台程序的版本。由于C语言不支持类，必须使用结构体和函数来模拟类的行为。

### `main.c`
```c

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define MAX_ROW 10
#define MAX_COL 10

typedef struct {
    int x;
    int y;
} Point;

typedef struct {
    bool passable; // 小球是否能通过
} Lattice;

typedef struct {
    int x; // 横坐标
    int y; // 纵坐标
} Ball;

typedef struct {
    Lattice maze[MAX_ROW + 2][MAX_COL + 2];
    Ball ball;
    Point entrance;
    Point exit;
    int rowNumber;
    int colNumber;
} Maze;

// 函数声明
void initializeMaze(Maze* maze);
void printMaze(Maze* maze);
bool isOutOfBorder(Point* p, Maze* maze);
void moveBall(Maze* maze, int direction);
bool isWin(Maze* maze);
void gameOverMessage(Maze* maze);

int main() {
    Maze maze;
    initializeMaze(&maze);
    printMaze(&maze);

    char command;
    while (true) {
        printf("Enter command (WASD to move, Q to quit): ");
        scanf(" %c", &command);

        switch (command) {
            case 'w': // Up
                moveBall(&maze, 0);
                break;
            case 's': // Down
                moveBall(&maze, 1);
                break;
            case 'a': // Left
                moveBall(&maze, 2);
                break;
            case 'd': // Right
                moveBall(&maze, 3);
                break;
            case 'q':
                exit(0);
            default:
                printf("Invalid command!\n");
                continue;
        }

        printMaze(&maze);
        if (isWin(&maze)) {
            gameOverMessage(&maze);
            break;
        }
    }

    return 0;
}

// 初始化迷宫
void initializeMaze(Maze* maze) {
    maze->rowNumber = MAX_ROW;
    maze->colNumber = MAX_COL;
    // Initialize entrance and exit
    maze->entrance.x = 0;
    maze->entrance.y = 1;
    maze->exit.x = maze->colNumber + 1;
    maze->exit.y = maze->rowNumber;

    // Set all cells as non-passable (walls)
    for (int i = 0; i < maze->rowNumber + 2; i++) {
        for (int j = 0; j < maze->colNumber + 2; j++) {
            maze->maze[i][j].passable = false;
        }
    }

    // Open the entrance and exit
    maze->maze[maze->entrance.y][maze->entrance.x].passable = true;
    maze->maze[maze->exit.y][maze->exit.x].passable = true;

    // Set the ball's starting position at the entrance
    maze->ball.x = maze->entrance.x;
    maze->ball.y = maze->entrance.y;
}

// 打印迷宫
void printMaze(Maze* maze) {
    for (int i = 0; i < maze->rowNumber + 2; i++) {
        for (int j = 0; j < maze->colNumber + 2; j++) {
            if(j == maze->ball.x && i == maze->ball.y){
                printf("o "); // Ball
            }
            else if (i == maze->entrance.y && j == maze->entrance.x) {
                printf("s "); // Entrance
            } else if (i == maze->exit.y && j == maze->exit.x) {
                printf("e "); // Exit
            } else if (maze->maze[i][j].passable) {
                printf("  "); // Passable space
            } else {
                printf("* "); // Wall
            }
        }
        printf("\n");
    }

    printf("Ball position: (%d, %d)\n", maze->ball.x, maze->ball.y);
}

// 检查是否出界
bool isOutOfBorder(Point* p, Maze* maze) {
    return (p->x < 0 || p->x > maze->colNumber + 1 || 
            p->y < 0 || p->y > maze->rowNumber + 1);
}

// 移动小球
void moveBall(Maze* maze, int direction) {
    Ball newPosition = maze->ball;

    switch (direction) {
        case 0: // Up
            printf("up\r\n");
            newPosition.y -= 1;
            break;
        case 1: // Down
        printf("down\r\n");
            newPosition.y += 1;

            break;
        case 2: // Left
        printf("left\r\n");
            newPosition.x -= 1;
            break;
        case 3: // Right
        printf("right\r\n");
            newPosition.x += 1;
            break;
    }

    if (!isOutOfBorder(&newPosition, maze) && maze->maze[newPosition.y][newPosition.x].passable) {
        maze->ball = newPosition;
    } else {
        printf("Can't move there!\n");
    }
}

// 检查是否赢得游戏
bool isWin(Maze* maze) {
    return (maze->ball.x == maze->exit.x && maze->ball.y == maze->exit.y);
}

// 游戏结束消息
void gameOverMessage(Maze* maze) {
    printf("Congratulations on getting out of the maze!");
}

```

### 代码说明
1. 我定义了一个 `Maze` 结构体，其中包括迷宫的格子、球的位置以及入口和出口。
2. `initializeMaze` 函数用于初始化迷宫，包括设置墙体、入口和出口。
3. `printMaze` 函数用于在控制台显示当前迷宫的状态，使用字符表示可通行和不可通行的格子。
4. `moveBall` 函数根据用户输入的方向移动小球。
5. 在 `main` 函数中，程序循环读取用户输入的命令，根据命令调用相应的移动函数，进行游戏逻辑处理。

请注意，这个 C 语言版本的程序没有实现生成迷宫的算法，所以迷宫的布局是静态的。进一步的提高可以包括实现迷宫生成和解决算法，响应用户输入的更复杂的操作等。
------------------------------
代码没有迷宫生成逻辑,请添加,示例java代码
```java
abstract class AbstractCreateMaze {
	// 验证横纵坐标是否超界
	protected boolean isOutofBorder(int x, int y, int colNumber, int rowNumber) {
		if ((x == 0 && y == 1) || (x == colNumber + 1 && y == rowNumber))
			return false;
		else
			return (x > colNumber || y > rowNumber || x < 1 || y < 1) ? true : false;
	}

	abstract void createMaze(Lattice[][] mazeLattice, int colNumber, int rowNumber);
}

class DepthFirstSearchCreateMaze extends AbstractCreateMaze {

	// 随机选择一个p点未访问的相邻迷宫单元 ,并移除两者之间的墙，为createMaze()函数调用
	protected Point ArroundPoint(Lattice[][] mazeLattice, Point p, Stack<Point> s, Random rand, int colNumber,
			int rowNumber) {
		final int[] arroundPoint = { -2, 0, 2, 0, -2 };// 一个点周围四个点的坐标变化，顺序为左上右下
		int r = rand.nextInt(4);
		for (int i = 0; i < 4; ++i) {
			int j = r % 4;
			int x = p.x + arroundPoint[j];
			int y = p.y + arroundPoint[j + 1];
			++r;
			if (!isOutofBorder(x, y, colNumber, rowNumber) && !mazeLattice[y][x].isPassable()) {
				mazeLattice[y][x].setPassable(true);
				mazeLattice[p.y + arroundPoint[j + 1] / 2][p.x + arroundPoint[j] / 2].setPassable(true);
				return new Point(x, y);
			}
		}
		return null;
	}

	@Override
	public void createMaze(Lattice[][] mazeLattice, int colNumber, int rowNumber) {
		// TODO Auto-generated method stub
		Random rand = new Random();
		Point currentPoint = new Point(2 * rand.nextInt(colNumber / 2) + 1, 2 * rand.nextInt(rowNumber / 2) + 1);
		mazeLattice[currentPoint.y][currentPoint.x].setPassable(true);
		Stack<Point> pathStack = new Stack<Point>();
		pathStack.push(currentPoint);
		currentPoint = ArroundPoint(mazeLattice, currentPoint, pathStack, rand, colNumber, rowNumber);
		while (true) {
			Point p = ArroundPoint(mazeLattice, currentPoint, pathStack, rand, colNumber, rowNumber);
			if (p != null) {
				pathStack.push(currentPoint);
				currentPoint = p;
			} else if (!pathStack.isEmpty())
				currentPoint = pathStack.pop();
			else
				break;
		}
	}
}

```

------------------------------
下面是一个包含迷宫生成逻辑的完整 C 语言控制台程序版本。这个实现使用深度优先搜索（DFS）算法来生成迷宫，模仿您提供的 Java 示例。

### `main.c`
```c

```

### 代码说明
1. **迷宫生成逻辑**: `createMaze` 函数使用 DFS 算法生成迷宫。`deepFirstSearch` 采用递归方式打开路径。随机打乱的方向可以避免生成相同的迷宫布局。
2. **随机化方向**: `randomizeDirections` 函数用于随机打乱相邻格子的排列顺序，以确保生成的每个迷宫都是独一无二的。
3. **基于移动的迷宫**: 迷宫可以通过输入 `WASD` 键来控制球的移动，程序会检测球是否移动到出口并结束游戏。
4. **状态检查函数**: `isOutOfBorder`、`isWin` 和 `gameOverMessage` 函数分别用于检查出界、胜利条件和输出游戏结束的消息。

此代码示例产生一个动态生成的迷宫，你可以在控制台中操作小球并在迷宫中探险。
------------------------------
这个迷宫游戏需要每次按回车键控制,请将它改成不需要按回车键即可控制。另外,这个游戏是运行在windows控制台power shell上的。

