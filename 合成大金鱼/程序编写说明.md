功能机冒泡平台编写说明：
1. 功能机平台使用mrpbuilder编译器进行编译（实际上是调用的ads1.2中的armcc编译器），采用C98标准，不支持C99
2. 不能使用线程，使用定时器模拟游戏主循环
3. 绘图结束后必须调用mrc_refreshScreen来更新屏幕区域，否则无法屏幕无法显示
4. mrc_init mrc_event mrc_pause mrc_resume mrc_exitApp是程序的入口函数，必须实现
5. mrc_extRecvAppEvent mrc_extRecvAppEventEx 是插件调用函数，保留它
6. 变量不能在mrc_init之外初始化，请将初始化赋值写到mrc_init里面
7. 不支持C语言的系统头文件，例如string.h stdlib.h，memcpy memset等函数仍然可以使用，只是被替换成了以下函数：
```h
#define malloc   mrc_malloc   
#define free     mrc_free     
#define strchr   mrc_strchr   
#define memcpy   mrc_memcpy   
#define memmove  mrc_memmove  
#define strcpy   mrc_strcpy   
#define strncpy  mrc_strncpy  
#define strcat   mrc_strcat   
#define strncat  mrc_strncat  
#define memcmp   mrc_memcmp   
#define strcmp   mrc_strcmp   
#define strncmp  mrc_strncmp  
#define strcoll  mrc_strcoll  
#define memchr   mrc_memchr   
#define memset   mrc_memset   
#define strlen   mrc_strlen   
#define strstr   mrc_strstr   
#define sprintf  mrc_sprintf             
#define atoi     mrc_atoi     
#define strtoul  mrc_strtoul  
```


可以调用以下头文件：mrc_base.h uc3_font.h mrc_graphics.h

以下声明在mrc_base.h头文件中
```c
typedef  unsigned short     uint16;      //有符号16bit整型
typedef  unsigned long int  uint32;      //无符号32bit整型
typedef  long int                int32;      //有符号32bit整型
typedef  unsigned char      uint8;        //无符号8bit整型
typedef  signed char          int8;        //有符号8bit整型
typedef  signed short         int16;       //有符号16bit整型
//基本按键值（未定义的其他按键也可以使用，但需知道其键值）
enum {  
   _0,           //按键 0
   _1,           //按键 1
   _2,           //按键 2
   _3,           //按键 3
   _4,           //按键 4
   _5,           //按键 5
   _6,           //按键 6
   _7,           //按键 7
   _8,           //按键 8
   _9,           //按键 9
   _STAR,        //按键 *
   _POUND,       //按键 #
   _UP,          //按键 上
   _DOWN,        //按键 下
   _LEFT,        //按键 左
   _RIGHT,       //按键 右
   _SLEFT=17,    //按键 左软键
   _SRIGHT,      //按键 右软键
   _SEND,        //按键 接听键
   _SELECT       //按键 确认/选择（若方向键中间有确认键，建议设为该键）
};

//基本事件（其他事件需自己定义）
enum {
    KY_DOWN, 	 //按键按下
    KY_UP,       //按键释放
    MS_DOWN, 	 //鼠标按下
    MS_UP 	     //鼠标释放
};
extern int16 SCRW;   //表示屏幕宽度
extern int16 SCRH ; //表示屏幕高度

typedef struct {
 uint16* bitmap;
 int width; //
 int height;
 int color_bit; //颜色位数 默认16
 int transcolor; //透明色 默认0xffff
 int mode; //绘制模式 默认BM_COPY
 int32 buflen; //缓存区宽高
} BITMAP_565; 

/*
程序入口函数,类似于main
*/
int32 mrc_init(void):
/*
程序事件函数,主要用于接受触屏/按键事件
当code==KY_UP或KY_DOWN时表示案件按键事件,param0为按键键值
当code==MS_UP或MS_DOWN时表示触屏事件 param0和param1为点击的屏幕坐标
*/
int32 mrc_event(int32 code, int32 param0, int32 param1);
/*
程序退出事件函数,在这里处理释放内存等操作
*/
int32 mrc_exitApp();

```
功能机可调用以下函数,这些函数定义在mrc_base.h:
```c

//取屏幕缓冲区的内存地址
uint16 * w_getScreenBuffer(void);

/*
创建定时器

返回:
      非NULL     定时器句柄
      NULL          失败
*/
int32 mrc_timerCreate (void);

/*
删除定时器

输入:
t           定时器句柄
*/
void mrc_timerDelete (int32 t);

/*
停止定时器

输入:
t           定时器句柄
*/
void mrc_timerStop (int32 t);
/*
定时器回调函数
输入:
data:
   启动定时器时传入的data参数。
*/
typedef void (*mrc_timerCB)(int32 data);

/*
启动定时器

输入:
t           定时器句柄
time      定时器时长，单位毫秒
data      定时器数据
f           定时器回调函数
loop      是否循环；0:不循环，1:循环

返回:
      MR_SUCCESS     成功
      MR_FAILED         失败
*/
int32 mrc_timerStart (int32 t, int32 time, int32 data, mrc_timerCB f, int32 loop);
/*
使用指定的颜色清除屏幕。
输入:
r,g,b	          绘制颜色
*/
void mrc_clearScreen(int32 r, int32 g, int32 b);

/*
刷新屏幕指定的区域。该函数的功能是将mythroad屏幕
缓冲指定的区域刷新到屏幕上。
输入:
x, y, w, h	       屏幕指定的区域（左上角为（x,y），宽高
                        为（w,h））
*/
void mrc_refreshScreen(int16 x, int16 y, uint16 w, uint16 h);


/*
在屏幕的指定位置绘制点。
输入:
x, y	           绘制点的位置
r,g,b	          绘制颜色
*/
void mrc_drawPointEx(int16 x, int16 y, int32 r, int32 g, int32 b);
```

以下声明在uc3_font.h头文件中
```c
//初始化uc3字体
int32 uc3_init(void);

// 画uc3字体
int32 uc3_drawText(char* pcText, int16 x, int16 y, uint8 r, uint8 g, uint8 b, int is_unicode);

//横屏绘制文字
int32 uc3_drawTextHor(char *pcText, int16 x, int16 y, uint8 r, uint8 g, uint8 b, int is_unicode);

// 获取文字宽度
int uc3_getWidth(char *pcText, int is_unicode);

// 释放uc3字体
void uc3_free(void);
```

以下声明在mrc_graphics.h头文件中，这个头文件的绘制操作中color变量颜色格式为ARGB格式，例如红色为0xFFFF0000
```
enum
{
    _JPG = 0,
    _PNG = 1,
    _BMP16 = 2
};

typedef struct
{
    uint32 width;  // 宽度
    uint32 height; // 高度
    uint32 stride;
    int32 format; // 格式
    uint32 flags; // 0 for now
    void *ptr;    // 缓存
} BITMAPINFO;

typedef struct
{
    int16 A; // A, B, C, and D are fixed point values with an 8-bit integer part
    int16 B; // and an 8-bit fractional part.
    int16 C;
    int16 D;
    uint16 rop;
} mr_transMatrixSt;


enum
{
    SHADE_UPDOWN,    // 从上到下
    SHADE_LEFTRIGHT, // 从左到右
    SHADE_DOWNUP,    // 从下到上
    SHADE_RIGHTLEFT  // 从右到左
};


#define GRAPHICS_LEFT 3
#define GRAPHICS_TOP 48
#define GRAPHICS_RIGHT 5
#define GRAPHICS_CENTER 17
#define GRAPHICS_BOTTOM 80


// 从内存卡读取bitmap
extern BITMAP_565 *readBitmap(char *filename);

// 从资源文件中读取bitmap
extern BITMAP_565 *readBitmap565FromAssets(const char *filename);
// 绘制bitmap
/*
src: 源图像对象，即要从中提取区域的图像。
x_src: 源图像中要提取区域的左上角的x坐标。
y_src: 源图像中要提取区域的左上角的y坐标。
width: 要提取区域的宽度。
height:要提取区域的高度。
transform:变换类型
x_dest: 目标位置的x坐标，即绘制提取区域的目标位置的左上角的x坐标。
y_dest: 目标位置的y坐标，即绘制提取区域的目标位置的左上角的y坐标。
anchor: 锚点，指定目标位置的参考点。常见的锚点包括：GRAPHICS_LEFT,GRAPHICS_TOP,GRAPHICS_RIGHT,GRAPHICS_BOTTOM,GRAPHICS_CENTER
*/
extern void drawBitmapRegion(BITMAP_565 *src, int x_src, int y_src, int width, int height, int transform, int x_dest, int y_dest, int anchor);

// 画图片 （自动识别位图格式RGB565或者32位图）
void drawBitmap(BITMAP_565 *bmp, int32 x, int32 y);

// 释放bitmap
extern int32 bitmapFree(BITMAP_565 *b);

void gl_drawColor(uint32 color);
void gl_clearScreen(int32 r, int32 g, int32 b);
// 画矩形
void gl_drawRect(int32 x, int32 y, int32 w, int32 h, uint32 color);
void gl_drawHollowRect(int x, int y, int width, int height, uint32 color);
// 画线
void gl_drawLine(int32 x1, int32 y1, int32 x2, int32 y2, uint32 color);
// 绘制三角形
void gl_drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, uint32 color);
// 绘制空心三角形
void gl_drawHollowTriangle(int x1, int y1, int x2, int y2, int x3, int y3, uint32 color);
// 画圆
void gl_drawCir(int32 x, int32 y, int32 r, uint32 color);
// 绘制空心圆
void gl_drawHollowCir(int x0, int y0, int r, uint32 color);
// 绘制旋转的矩形
void gl_drawRotatedRect(int16 centerX, int16 centerY, int16 width, int16 height, int32 bx, int32 by, float angle, uint32 color);
// 绘制旋转的空心矩形
void gl_drawRotatedHollowRect(int16 centerX, int16 centerY, int16 width, int16 height, int32 bx, int32 by, float angle, uint32 color);

// 将bitmap缩放,生成一个新的BITMAP
BITMAP_565 *createBitmapFromBitmap(BITMAP_565 *bmp, int32 width, int32 height);

// 获取bitmap信息
int32 bitmap565getInfo(BITMAP_565 *bmp, BITMAPINFO *info);
/*
将bitmap旋转绘制到屏幕上
scrx scry 绘制到屏幕上的中心位置
bx by 图片旋转中心
*/
void drawBitmapRotate(BITMAP_565 *b, int32 scrx, int32 scry, int32 bx, int32 by, int32 r);

#endif
```