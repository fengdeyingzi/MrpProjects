<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åˆæˆå¤§é‡‘é±¼ - æ¢¦å¹»æ°´æ—é¦†</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #e0f7fa;
            font-family: 'ZCOOL KuaiLe', sans-serif; /* å¯çˆ±çš„å­—ä½“ */
            touch-action: none; /* é˜²æ­¢æ‰‹æœºç«¯æ»šåŠ¨ */
        }

        /* æ¸¸æˆå®¹å™¨ */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #81d4fa 0%, #29b6f6 40%, #0288d1 100%);
        }

        /* é±¼ç¼¸èƒŒæ™¯è£…é¥° - æ°”æ³¡ */
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            animation: float 8s infinite ease-in;
            bottom: -50px;
            pointer-events: none;
        }
        @keyframes float {
            0% { transform: translateY(0) scale(1); opacity: 0; }
            50% { opacity: 0.6; }
            100% { transform: translateY(-110vh) scale(1.5); opacity: 0; }
        }

        canvas {
            background: rgba(255, 255, 255, 0.1); /* ç»ç’ƒè´¨æ„Ÿ */
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 0 0 15px 15px;
            cursor: pointer;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
        }

        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }

        #next-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            color: white;
            backdrop-filter: blur(5px);
        }

        #game-over-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
        }

        .btn {
            background: #ff9800;
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 5px #f57c00;
            transition: transform 0.1s;
        }
        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 0 #f57c00;
        }

        h1 { color: #fff; font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 10px #ffeb3b; }
        
        /* è­¦å‘Šçº¿æç¤º */
        #limit-line-hint {
            position: absolute;
            top: 150px; /* å¯¹åº”ä»£ç ä¸­çš„ limitY */
            width: 100%;
            border-top: 2px dashed rgba(255, 100, 100, 0.6);
            display: none; 
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- åŠ¨æ€ç”Ÿæˆçš„èƒŒæ™¯æ°”æ³¡ -->
    <div id="bubbles-container"></div>

    <canvas id="world"></canvas>

    <div id="limit-line-hint"></div>

    <div id="ui-layer">
        <div id="score-board">
            <div>åˆ†æ•°: <span id="score">0</span></div>
            <div style="font-size: 0.8em; opacity: 0.8;">æœ€é«˜: <span id="best-score">0</span></div>
        </div>
        <div id="next-preview">
            <div style="font-size: 14px; margin-bottom: 5px;">ä¸‹ä¸€ä¸ª</div>
            <div id="next-item-icon" style="font-size: 30px;">ğŸ’§</div>
        </div>
    </div>

    <div id="game-over-screen">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p style="color:white; font-size: 24px; margin-bottom: 30px;">æœ€ç»ˆå¾—åˆ†: <span id="final-score">0</span></p>
        <button class="btn" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<!-- å¼•å…¥ Matter.js ç‰©ç†å¼•æ“ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
    // ---------------------- é…ç½®ä¸æ•°æ® ----------------------
    
    // ç”Ÿç‰©åˆæˆåºåˆ—
    const FISH_TYPES = [
        { level: 0, radius: 20,  val: 1,   icon: "ğŸ’§", color: "#E1F5FE", name: "æ°´æ»´" },
        { level: 1, radius: 30,  val: 3,   icon: "ğŸµ", color: "#B3E5FC", name: "å°èŒèšª" }, // ç”¨éŸ³ç¬¦ä»£è¡¨èŒèšªçš„çµåŠ¨
        { level: 2, radius: 42,  val: 6,   icon: "ğŸ’¡", color: "#FFF59D", name: "ç¯é±¼" },
        { level: 3, radius: 56,  val: 10,  icon: "ğŸ ", color: "#FFCC80", name: "å°ä¸‘é±¼" },
        { level: 4, radius: 72,  val: 15,  icon: "ğŸŸ", color: "#90CAF9", name: "ç¥ä»™é±¼" },
        { level: 5, radius: 90,  val: 21,  icon: "ğŸ", color: "#EF9A9A", name: "é”¦é²¤" },
        { level: 6, radius: 110, val: 28,  icon: "ğŸ‰", color: "#C5E1A5", name: "é‡‘é¾™é±¼" },
        { level: 7, radius: 132, val: 36,  icon: "ğŸª¼", color: "#E1BEE7", name: "å‘å…‰æ°´æ¯" },
        { level: 8, radius: 156, val: 45,  icon: "ğŸ¢", color: "#A5D6A7", name: "æµ·é¾Ÿ" },
        { level: 9, radius: 180, val: 100, icon: "ğŸ‘‘", color: "#FFD54F", name: "å¤§é‡‘é±¼" } // ç»ˆæç›®æ ‡
    ];

    // æ¸¸æˆå¸¸é‡
    const GAME_WIDTH = 450; // é±¼ç¼¸å®½åº¦
    const GAME_HEIGHT = 750; // é±¼ç¼¸é«˜åº¦
    const WALL_THICKNESS = 50;
    const LIMIT_LINE_Y = 150; // è­¦æˆ’çº¿é«˜åº¦

    // Matter.js æ¨¡å—åˆ«å
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body,
          Vector = Matter.Vector;

    // å…¨å±€å˜é‡
    let engine, world, render, runner;
    let score = 0;
    let bestScore = localStorage.getItem('goldfish_best') || 0;
    let currentFishType = 0;
    let nextFishType = 0;
    let isGameOver = false;
    let canDrop = true;
    let currentDropper = null; // å½“å‰æ­£åœ¨é¡¶éƒ¨è·Ÿéšé¼ æ ‡çš„ç‰©ä½“ï¼ˆåªæ˜¯ä¸€ä¸ªè§†è§‰é¢„è§ˆï¼Œä¸æ˜¯ç‰©ç†å®ä½“ï¼‰
    
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('best-score');
    const nextIconEl = document.getElementById('next-item-icon');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const limitLineEl = document.getElementById('limit-line-hint');

    // ---------------------- åˆå§‹åŒ– ----------------------

    function init() {
        bestScoreEl.innerText = bestScore;
        
        // è®¾ç½® Canvas å¤§å° (é€‚é…ç§»åŠ¨ç«¯)
        let containerW = window.innerWidth;
        let containerH = window.innerHeight;
        
        // ä¿æŒå®½é«˜æ¯”ï¼Œé™åˆ¶æœ€å¤§å®½åº¦
        let targetWidth = Math.min(GAME_WIDTH, containerW - 20);
        let targetHeight = Math.min(GAME_HEIGHT, containerH - 20);
        
        canvas.width = targetWidth;
        canvas.height = targetHeight;

        // æ›´æ–°è­¦æˆ’çº¿è§†è§‰ä½ç½®
        limitLineEl.style.top = (LIMIT_LINE_Y * (targetHeight / GAME_HEIGHT)) + "px";
        limitLineEl.style.width = targetWidth + "px";

        // åˆ›å»ºç‰©ç†å¼•æ“
        engine = Engine.create();
        world = engine.world;
        
        // è°ƒæ•´é‡åŠ› (æ°´ä¸‹æ„Ÿè§‰é‡åŠ›ç¨ä½ï¼Œæˆ–è€…é˜»åŠ›å¤§)
        engine.gravity.y = 1.2; 

        // åˆ›å»ºè¾¹ç•Œ
        createWalls(targetWidth, targetHeight);

        // è¾“å…¥äº‹ä»¶ç»‘å®š
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('click', onMouseClick);
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd, {passive: false});

        // ç¢°æ’æ£€æµ‹äº‹ä»¶
        Events.on(engine, 'collisionStart', handleCollisions);

        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        requestAnimationFrame(gameLoop);

        // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªç”Ÿç‰©
        setNextFish();
        spawnNewDropper();
    }

    // åˆ›å»ºå¢™å£
    function createWalls(w, h) {
        const ground = Bodies.rectangle(w/2, h + WALL_THICKNESS/2 - 10, w, WALL_THICKNESS, { isStatic: true, render: { visible: false } });
        const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, h/2, WALL_THICKNESS, h * 2, { isStatic: true, render: { visible: false } });
        const rightWall = Bodies.rectangle(w + WALL_THICKNESS/2, h/2, WALL_THICKNESS, h * 2, { isStatic: true, render: { visible: false } });

        Composite.add(world, [ground, leftWall, rightWall]);
    }

    // ---------------------- æ¸¸æˆé€»è¾‘ ----------------------

    function setNextFish() {
        // åªç”Ÿæˆå‰ 5 ç§çº§åˆ«çš„å°ç”Ÿç‰© (0-4)
        nextFishType = Math.floor(Math.random() * 5);
        nextIconEl.innerText = FISH_TYPES[nextFishType].icon;
        nextIconEl.style.textShadow = `0 0 10px ${FISH_TYPES[nextFishType].color}`;
    }

    function spawnNewDropper() {
        if (isGameOver) return;
        currentFishType = nextFishType;
        setNextFish();
        canDrop = true;
        
        // åˆå§‹åŒ– Dropper ä½ç½®åœ¨ä¸­é—´
        currentDropper = {
            x: canvas.width / 2,
            y: 50,
            level: currentFishType
        };
    }

    // é¼ æ ‡/è§¦æ‘¸ç§»åŠ¨å¤„ç†
    function updateDropperPos(clientX) {
        if (!canDrop || isGameOver) return;
        
        const rect = canvas.getBoundingClientRect();
        let x = clientX - rect.left;
        
        // é™åˆ¶åœ¨å¢™å£å†…
        const radius = FISH_TYPES[currentFishType].radius;
        if (x < radius) x = radius;
        if (x > canvas.width - radius) x = canvas.width - radius;

        currentDropper.x = x;
    }

    function onMouseMove(e) { updateDropperPos(e.clientX); }
    function onTouchMove(e) { e.preventDefault(); updateDropperPos(e.touches[0].clientX); }
    function onTouchStart(e) { e.preventDefault(); updateDropperPos(e.touches[0].clientX); }
    function onTouchEnd(e) {
        e.preventDefault();
        // ä»æœ€åè§¦æ‘¸ç‚¹çš„ä½ç½®æŠ•æ”¾
        if (e.changedTouches && e.changedTouches.length > 0) {
            updateDropperPos(e.changedTouches[0].clientX);
        }
        dropFish();
    }

    // æ”¾ç½®ç”Ÿç‰©
    function dropFish() {
        if (!canDrop || isGameOver) return;

        canDrop = false;
        
        const type = FISH_TYPES[currentFishType];
        // åˆ›å»ºç‰©ç†å®ä½“
        const body = Bodies.circle(currentDropper.x, currentDropper.y, type.radius, {
            restitution: 0.3, // å¼¹æ€§
            friction: 0.1,    // æ‘©æ“¦
            density: 0.002 * (type.level + 1), // é‡é‡éšç­‰çº§å¢åŠ 
            label: 'fish',
            plugin: {
                level: currentFishType // è‡ªå®šä¹‰å±æ€§ï¼šç­‰çº§
            }
        });

        Composite.add(world, body);

        // å»¶è¿Ÿç”Ÿæˆä¸‹ä¸€ä¸ª
        setTimeout(() => {
            spawnNewDropper();
        }, 800);
    }

    function onMouseClick() { dropFish(); }

    // ---------------------- ç‰©ç† & åˆæˆé€»è¾‘ ----------------------

    function handleCollisions(event) {
        if (isGameOver) return;

        const pairs = event.pairs;

        // ä½¿ç”¨ Set é˜²æ­¢åŒä¸€æ¬¡ç¢°æ’å¤„ç†å¤šæ¬¡
        const bodiesToRemove = new Set();
        const newBodiesToCreate = [];

        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA;
            const bodyB = pairs[i].bodyB;

            // ç¡®ä¿æ˜¯é±¼ä¸”æœªè¢«æ ‡è®°ç§»é™¤
            if (bodyA.label !== 'fish' || bodyB.label !== 'fish') continue;
            if (bodiesToRemove.has(bodyA.id) || bodiesToRemove.has(bodyB.id)) continue;

            // æ£€æŸ¥ç­‰çº§æ˜¯å¦ç›¸åŒ
            if (bodyA.plugin.level === bodyB.plugin.level) {
                const currentLevel = bodyA.plugin.level;
                
                // å¦‚æœä¸æ˜¯æœ€é«˜çº§ï¼Œåˆ™åˆæˆ
                if (currentLevel < FISH_TYPES.length - 1) {
                    // æ ‡è®°ç§»é™¤æ—§çš„
                    bodiesToRemove.add(bodyA);
                    bodiesToRemove.add(bodyB);

                    // è®¡ç®—æ–°ä½ç½®ï¼ˆä¸¤ä¸ªä¸­å¿ƒçš„ä¸­ç‚¹ï¼‰
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (bodyA.position.y + bodyB.position.y) / 2;

                    newBodiesToCreate.push({
                        x: midX,
                        y: midY,
                        level: currentLevel + 1
                    });

                    // åŠ åˆ†
                    addScore(FISH_TYPES[currentLevel].val * 2);
                }
            }
        }

        // æ‰§è¡Œç§»é™¤å’Œåˆ›å»º
        if (bodiesToRemove.size > 0) {
            Composite.remove(world, Array.from(bodiesToRemove));
            
            newBodiesToCreate.forEach(data => {
                const type = FISH_TYPES[data.level];
                const newBody = Bodies.circle(data.x, data.y, type.radius, {
                    restitution: 0.3,
                    label: 'fish',
                    plugin: { level: data.level }
                });
                Composite.add(world, newBody);
                
                // ç®€å•çš„åˆæˆç‰¹æ•ˆï¼ˆè¿™é‡Œç”¨consoleä»£æ›¿ï¼Œå®é™…åœ¨drawä¸­è¡¨ç°ï¼‰
                // console.log(`Synthesized: ${type.name}`);
            });
        }
    }

    function addScore(val) {
        score += val;
        scoreEl.innerText = score;
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('goldfish_best', bestScore);
            bestScoreEl.innerText = bestScore;
        }
    }

    function checkGameOver() {
        const bodies = Composite.allBodies(world);
        for (let body of bodies) {
            if (body.label === 'fish' && !body.isSleeping) {
                // å¦‚æœç‰©ä½“é™æ­¢ï¼ˆé€Ÿåº¦å¾ˆå°ï¼‰ä¸”é«˜åº¦è¶…è¿‡è­¦æˆ’çº¿
                // ä¸ºäº†å®½å®¹åº¦ï¼Œåªæœ‰å½“ç‰©ä½“yå€¼å°äº LIMIT_LINE_Y ä¸”å­˜æ´»äº†ä¸€æ®µæ—¶é—´æ‰ç®—è¾“
                // è¿™é‡Œç®€åŒ–ï¼šåªè¦æœ‰é™æ­¢çš„ç‰©ä½“è¶…å‡ºçº¢çº¿
                if (body.position.y < LIMIT_LINE_Y && body.speed < 0.5) {
                    // è¿™é‡Œéœ€è¦ä¸€ä¸ªè®¡æ—¶å™¨ç¡®è®¤ï¼Œé¿å…åˆšç”Ÿæˆæ—¶è¯¯åˆ¤
                    // ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾å¦‚æœå®ƒåœ¨ä¸Šé¢å¤ªä¹…
                    if (!body.plugin.dangerTime) body.plugin.dangerTime = 0;
                    body.plugin.dangerTime++;
                    
                    if (body.plugin.dangerTime > 100) { // çº¦1.6ç§’
                        triggerGameOver();
                    }
                } else {
                    body.plugin.dangerTime = 0;
                }
            }
        }
    }

    function triggerGameOver() {
        isGameOver = true;
        finalScoreEl.innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    window.restartGame = function() {
        // æ¸…ç©ºç‰©ç†ä¸–ç•Œ
        Composite.clear(world, false); // keep static bodies if structured differently, but here we recreate
        // ç®€å•èµ·è§ï¼Œé‡æ–°åˆå§‹åŒ– world å†…å®¹ï¼Œä¿ç•™ engine
        Composite.clear(world, false);
        engine.events = {}; // æ¸…é™¤äº‹ä»¶ä»¥å…ç´¯ç§¯
        
        // é‡æ–°åŠ è½½é¡µé¢æœ€ç®€å•ï¼Œä½†ä¸ºäº†ä½“éªŒå¥½ï¼Œæˆ‘ä»¬é‡ç½®å˜é‡
        score = 0;
        scoreEl.innerText = '0';
        isGameOver = false;
        gameOverScreen.style.display = 'none';
        
        // é‡æ–°æ·»åŠ å¢™å£
        let w = canvas.width;
        let h = canvas.height;
        createWalls(w, h);

        Events.on(engine, 'collisionStart', handleCollisions);
        
        spawnNewDropper();
    }

    // ---------------------- æ¸²æŸ“å¾ªç¯ ----------------------

    function draw() {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. ç»˜åˆ¶è­¦æˆ’çº¿
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255, 100, 100, 0.3)";
        ctx.setLineDash([10, 10]);
        ctx.moveTo(0, LIMIT_LINE_Y);
        ctx.lineTo(canvas.width, LIMIT_LINE_Y);
        ctx.stroke();
        ctx.setLineDash([]);

        // 2. ç»˜åˆ¶ç‰©ç†ä¸–ç•Œä¸­çš„é±¼
        const bodies = Composite.allBodies(world);
        bodies.forEach(body => {
            if (body.label === 'fish') {
                drawFish(body.position.x, body.position.y, body.angle, body.plugin.level);
            }
        });

        // 3. ç»˜åˆ¶å½“å‰çš„ Dropper (é¢„è§ˆ)
        if (canDrop && currentDropper && !isGameOver) {
            drawFish(currentDropper.x, currentDropper.y, 0, currentDropper.level, true);
            // ç»˜åˆ¶è¾…åŠ©çº¿
            ctx.beginPath();
            ctx.moveTo(currentDropper.x, currentDropper.y + FISH_TYPES[currentDropper.level].radius);
            ctx.lineTo(currentDropper.x, canvas.height);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            ctx.stroke();
        }
    }

    function drawFish(x, y, angle, level, isPreview = false) {
        const type = FISH_TYPES[level];
        const r = type.radius;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        if (isPreview) {
            ctx.globalAlpha = 0.6;
        }

        // ç»˜åˆ¶åœ†å½¢èº«ä½“ (æ°´å½©é£æ ¼ï¼šæ¸å˜)
        const gradient = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
        gradient.addColorStop(0, "#FFFFFF");
        gradient.addColorStop(0.3, type.color);
        gradient.addColorStop(1, darkenColor(type.color, -20)); // è¾¹ç¼˜ç¨æš—

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, 2 * Math.PI);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // è¾¹ç¼˜æè¾¹
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // ç»˜åˆ¶ Emoji
        ctx.font = `${r}px sans-serif`; // Emoji å¤§å°éšåŠå¾„å˜åŒ–
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // ç¨å¾®è°ƒæ•´ Emoji çš„å‚ç›´åç§»ï¼Œä½¿å…¶è§†è§‰å±…ä¸­
        ctx.fillStyle = "#000"; 
        
        // ç‰¹æ®Šå¤„ç†å¤§é‡‘é±¼çš„é—ªå…‰æ•ˆæœ
        if (level === 9) {
            ctx.shadowColor = "#FFD700";
            ctx.shadowBlur = 20;
        }

        ctx.fillText(type.icon, 0, r * 0.1);

        // æ¢å¤
        ctx.restore();
    }

    // è¾…åŠ©é¢œè‰²å˜æš—å‡½æ•°
    function darkenColor(color, amount) {
        return color; // ç®€å•èµ·è§ç›´æ¥è¿”å›åŸè‰²ï¼Œæˆ–è€…å¯ä»¥ä½¿ç”¨åº“å¤„ç†é¢œè‰²
    }

    function gameLoop() {
        Engine.update(engine, 1000 / 60);
        draw();
        checkGameOver();
        requestAnimationFrame(gameLoop);
    }

    // ---------------------- é¡µé¢è£…é¥°é€»è¾‘ ----------------------
    
    // ç”ŸæˆèƒŒæ™¯æ³¡æ³¡
    const bubblesContainer = document.getElementById('bubbles-container');
    for(let i=0; i<15; i++) {
        let b = document.createElement('div');
        b.className = 'bubble';
        let size = Math.random() * 20 + 10;
        b.style.width = size + 'px';
        b.style.height = size + 'px';
        b.style.left = Math.random() * 100 + 'vw';
        b.style.animationDuration = (Math.random() * 5 + 5) + 's';
        b.style.animationDelay = Math.random() * 5 + 's';
        bubblesContainer.appendChild(b);
    }

    // å¯åŠ¨
    window.onload = init;

</script>
</body>
</html>