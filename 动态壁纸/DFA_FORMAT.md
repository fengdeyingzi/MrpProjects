# DFA 文件格式规范

**DFA** = 差分帧动画

专为16位RGB565图像序列优化的自定义动画格式，采用差分压缩。

## 版本信息
- 当前版本：1
- 字节顺序：小端序

---

## 文件结构

```
[文件头 (16 字节)]
[帧头 (6 字节)][帧数据 (可变长度)]
[帧头 (6 字节)][帧数据 (可变长度)]
...
```

---

## 1. 文件头 (16 字节)

| 偏移量 | 大小 | 类型     | 名称                | 描述                               |
|--------|------|----------|---------------------|-----------------------------------|
| 0      | 4    | char[]   | magic               | 魔数: "DFA\0"                     |
| 4      | 2    | uint16   | version             | 格式版本 (1)                       |
| 6      | 2    | uint16   | width               | 图像宽度 (像素)                    |
| 8      | 2    | uint16   | height              | 图像高度 (像素)                    |
| 10     | 2    | uint16   | total_frames        | 总帧数                            |
| 12     | 2    | uint16   | keyframe_interval   | 关键帧插入间隔 (0=自动)            |
| 14     | 1    | uint8    | compression_mode    | 默认压缩模式 (见下文)               |
| 15     | 1    | uint8    | reserved            | 保留供未来使用                     |

### 压缩模式
- `0` = 自动 (在直接差分和RLE之间自动选择)
- `1` = 直接差分
- `2` = RLE (行程长度编码)

---

## 2. 帧头 (6 字节)

| 偏移量 | 大小 | 类型   | 名称       | 描述                         |
|--------|------|--------|------------|------------------------------|
| 0      | 1    | uint8  | frame_type | 帧类型 (见下文)               |
| 1      | 1    | uint8  | reserved   | 保留供未来使用                |
| 2      | 4    | uint32 | data_size  | 帧数据大小 (字节)             |

### 帧类型
- `0` = 关键帧 (完整帧)
- `1` = 差分帧 (相对于前一帧的变化)
- `2` = 跳过帧 (与前一帧相同)
- `16` = 矩形区域差分帧 (多个矩形区域的差分)
- `3-15, 17-255` = 保留供未来使用

---

## 3. 帧数据格式

### 图像尺寸限制

**支持的最大尺寸：**
- **最大像素数**: 4,294,967,295（uint32 最大值）
- **推荐最大**: 16,777,216（4096×4096）
- **性能考虑**: 超过 4K 分辨率建议使用分块处理

**块大小限制：**
- **最大块长度**: 65,535 像素（uint16 最大值）
- 对于连续变化区域，单个块最多覆盖 65,535 个像素
- 如果连续区域更大，会自动分割成多个块

---

### 3.1 关键帧 (类型 0)

完整的RGB565格式帧数据。

```
[像素_0 (uint16)][像素_1 (uint16)]...[像素_N (uint16)]
```

- 大小：`宽度 × 高度 × 2` 字节
- 像素按行主序存储 (从左到右，从上到下)
- 每个像素为16位RGB565小端序

**RGB565 格式:**
```
位:   15 14 13 12 11 | 10  9  8  7  6 | 5  4  3  2  1  0
      R  R  R  R  R  |  G  G  G  G  G  G | B  B  B  B  B
      |--- 红 -------|  |---- 绿 -------| |---- 蓝 -----|
         5 位             6 位               5 位
```

### 3.2 跳过帧 (类型 2)

无数据。显示前一帧不变。

```
(空，data_size = 0)
```

### 3.3 差分帧 (类型 1)

相对于前一帧的增量压缩帧。

```
[compression_mode (uint8)][compressed_data]
```

#### 3.3.1 直接差分 (模式 1)

发生变化的像素被分组为连续的块。

```
[块 1][块 2]...[块 N]
```

**块格式 (6 字节头部):**
```
[start_idx (uint32)][length (uint16)][pixel_data (uint16 × length)]
```

- `start_idx`：起始像素索引 (从0开始，行主序) - **uint32 以支持大图像**
- `length`：连续像素的数量 (最大 65,535)
- `pixel_data`：RGB565像素值

**块头大小：6 字节**
- `start_idx`: 4 字节 (uint32, 小端序)
- `length`: 2 字节 (uint16, 小端序)

**示例:**
如果像素100-102和200-204发生了变化:
```
块 1: start=100 (uint32), length=3, data=[像素100, 像素101, 像素102]
块 2: start=200 (uint32), length=5, data=[像素200, ..., 像素204]
```

**注意：** `start_idx` 使用 uint32 以支持超过 65,536 像素的图像（例如 240×426 = 102,240 像素）

#### 3.3.2 RLE 压缩 (模式 2)

行程长度编码连续相同颜色的像素。

```
[RLE 块 1][RLE 块 2]...[RLE 块 N]
```

**RLE 块格式 (6 字节):**
```
[pixel_idx (uint16)][repeat_count (uint16)][color (uint16)]
```

- `pixel_idx`：起始像素索引
- `repeat_count`：连续相同颜色像素的数量
- `color`：RGB565颜色值

**示例:**
如果像素100-104都变为红色 (0xF800):
```
RLE 块: pixel_idx=100, repeat_count=5, color=0xF800
```

---

## 3.4 矩形区域差分帧 (类型 16)

仅编码变化的矩形区域，适合弹窗、对话框、局部UI更新等场景。

### 3.4.1 数据结构

```
[rect_count (uint8)][rect_1][rect_2]...[rect_N]
```

- `rect_count`：矩形区域数量（1-255）

### 3.4.2 矩形区域格式

每个矩形区域的格式：

```
[x (uint16)][y (uint16)][width (uint16)][height (uint16)][pixel_data]
```

| 字段 | 大小 | 类型 | 描述 |
|------|------|------|------|
| x | 2 | uint16 | 矩形左上角 X 坐标 |
| y | 2 | uint16 | 矩形左上角 Y 坐标 |
| width | 2 | uint16 | 矩形宽度（像素） |
| height | 2 | uint16 | 矩形高度（像素） |
| pixel_data | width×height×2 | uint16[] | RGB565 像素数据（行主序） |

**数据大小：** 8 + width × height × 2 字节/矩形

### 3.4.3 示例

假设一个 240×426 的帧中有两个变化区域：
1. 弹窗区域：(50, 100) 位置，80×60 像素
2. 按钮区域：(100, 300) 位置，40×20 像素

```
偏移   数据                    描述
------  ----                   -----------
0x00    02                     rect_count = 2

// 矩形 1
0x01    32 00                  x = 50
0x03    64 00                  y = 100
0x05    50 00                  width = 80
0x07    3C 00                  height = 60
0x09    [9600 字节]            pixel_data (80×60×2)

// 矩形 2
0x2589  64 00                  x = 100
0x258B  2C 01                  y = 300
0x258D  28 00                  width = 40
0x258F  14 00                  height = 20
0x2591  [1600 字节]            pixel_data (40×20×2)
```

### 3.4.4 坐标系统

- 坐标原点 (0, 0) 位于图像左上角
- X 轴向右递增
- Y 轴向下递增
- 矩形区域必须完全在图像边界内：
  - `x + width ≤ 图像宽度`
  - `y + height ≤ 图像高度`

### 3.4.5 优势与适用场景

**优势：**
- 比逐像素差分更高效（无块头开销）
- 比块差分更适合局部更新（明确区域边界）
- 解码时可直接 DMA 到屏幕坐标
- 便于硬件加速（矩形填充操作）

**适用场景：**
- UI 动画（按钮、开关、进度条）
- 弹窗/对话框显示
- 局部刷新（通知、标签页切换）
- 光标/鼠标移动

**不适用场景：**
- 全屏变化（使用关键帧）
- 散点分布的变化（使用块差分）
- 复杂形状的变化（使用块差分）

---

## 4. RGB565 颜色转换

### RGB888 → RGB565
```c
uint16_t rgb565 = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
```

### RGB565 → RGB888
```c
uint8_t r = ((rgb565 >> 11) & 0x1F) * 255 / 31;
uint8_t g = ((rgb565 >> 5) & 0x3F) * 255 / 63;
uint8_t b = (rgb565 & 0x1F) * 255 / 31;
```

---

## 5. 编码策略

### 关键帧插入
- 第一帧始终是关键帧
- 每隔 `keyframe_interval` 帧插入一个关键帧 (如果 > 0)
- 如果变化像素超过总像素的70%，则自动插入关键帧

### 压缩模式选择 (自动模式)
- 分析变化像素的模式
- 如果超过30%的变化像素是连续且颜色相同，则使用RLE
- 否则使用直接差分

### 帧类型选择 (差分帧优化)

当确定使用差分帧时，可进一步选择最优编码方式：

#### 块差分 (类型 1) vs 矩形区域差分 (类型 16)

**选择算法：**
```
1. 计算块差分数据大小
2. 分析变化像素分布，尝试提取矩形区域
3. 计算矩形区域差分数据大小
4. 如果矩形区域差分更小，使用类型 16，否则使用类型 1
```

**矩形区域提取策略：**
- 使用连通区域检测算法找出变化像素的聚集区域
- 为每个聚集区域生成最小包围矩形
- 计算矩形覆盖效率：`变化像素数 / 矩形总像素数`
- 如果覆盖效率 > 阈值（建议 50-80%），则适合使用矩形区域差分

**数据大小对比：**
- 块差分：`1 + Σ(6 + block_length × 2)` 字节
- 矩形区域差分：`1 + rect_count × (8 + rect_width × rect_height × 2)` 字节

**典型适用场景：**
- 矩形区域差分更优：弹窗、对话框、按钮点击、局部UI刷新
- 块差分更优：散点变化、复杂形状、渐变动画

### 跳过帧
- 如果与前一帧相比没有像素发生变化

---

## 6. 解压缩算法

```
1. 读取文件头
2. 初始化 previous_frame = null
3. 对于每一帧:
   a. 读取帧头 (frame_type, reserved, data_size)
   b. 读取帧数据
   c. 根据帧类型解压缩:
      - 类型 0 (关键帧): 直接使用数据
      - 类型 1 (差分帧): 复制 previous_frame，应用块差分
      - 类型 2 (跳过帧): 复制 previous_frame
      - 类型 16 (矩形差分): 复制 previous_frame，应用矩形区域
   d. previous_frame = current_frame
4. 将RGB565帧转换为RGB888以供显示
```

### 矩形区域差分解码伪代码

```c
// 解码类型 16 帧
void decodeRectFrame(uint16_t* frame, const uint8_t* data,
                     int width, int height) {
    // frame 已经是前一帧的副本
    int offset = 0;

    // 读取矩形数量
    uint8_t rect_count = data[offset++];

    for (int i = 0; i < rect_count; i++) {
        // 读取矩形参数
        uint16_t x = readUint16(&data[offset]); offset += 2;
        uint16_t y = readUint16(&data[offset]); offset += 2;
        uint16_t w = readUint16(&data[offset]); offset += 2;
        uint16_t h = readUint16(&data[offset]); offset += 2;

        // 边界检查
        if (x + w > width || y + h > height) {
            // 错误：矩形超出边界
            return;
        }

        // 复制像素数据到帧缓冲区
        for (int row = 0; row < h; row++) {
            int frameIdx = (y + row) * width + x;
            for (int col = 0; col < w; col++) {
                frame[frameIdx + col] = readUint16(&data[offset]);
                offset += 2;
            }
        }
    }
}
```

---

## 7. 示例文件结构

```
偏移量   数据                    描述
------   ----                   -----------
0x0000   44 46 41 00            魔数 "DFA\0"
0x0004   01 00                  版本 1
0x0006   F0 00                  宽度: 240
0x0008   AA 01                  高度: 426
0x000A   14 00                  总帧数: 20
0x000C   0A 00                  关键帧间隔: 10
0x000E   00                     压缩: 自动
0x000F   00                     保留

0x0010   00                     帧 0: 类型=关键帧
0x0011   00                     保留
0x0012   E0 1E 03 00           数据大小: 204480 字节
0x0016   [204480 字节]          RGB565像素数据

0x31EF6  01                     帧 1: 类型=差分帧
0x31EF7  00                     保留
0x31EF8  34 92 00 00           数据大小: 37428 字节
0x31EFC  01                     压缩: 直接
0x31EFD  [37427 字节]           压缩的差分数据

...
```

---

## 8. 实现注意事项

### 性能优化
- 对像素数据使用类型化数组 (Uint16Array)
- 缓冲关键帧以减少解码开销
- 预分配帧缓冲区

### 内存考虑
- 最大帧大小: ~16.7 MB (4096×4096×2，使用uint32存储data_size)
- 典型压缩比: 3:1 到 10:1 (取决于内容)
- **块头开销**: 直接差分模式下每个块占用 6 字节（uint32 startIdx + uint16 length）

### 图像尺寸验证
- **推荐**: 在编码前检查 `width × height ≤ 4,294,967,295`
- **警告**: 超过 4096×4096 的图像应提示性能警告
- **错误**: 拒绝编码超过 uint32 范围的图像

### 错误处理
- 验证魔数
- 检查帧索引是否在有效范围内
- 验证数据大小是否符合预期值
- 优雅处理不完整/损坏的文件

---

## 9. 工具

### 命令行工具 (Dart)
```bash
# 编码
dart run dfa_main.dart -e -i "frames/frame_%04d.png" -o animation.dfa --start 0 --end 99

# 解码
dart run dfa_main.dart -d -i animation.dfa -o "output/frame_%04d.png"
```

### HTML 查看器
请参阅 `dfa_viewer.html` 获取基于Web的动画播放器。

---

## 10. 版本历史

### 版本 1 (当前)
- 初始版本
- RGB565 格式
- 三种帧类型: 关键帧，差分帧，跳过帧
- 两种压缩模式: 直接，RLE
- 支持最多4GB的帧数据
- **2025-12-06 修复**: 直接差分块头的 `start_idx` 从 uint16 改为 uint32，修复大图像（>65536像素）的溢出问题
- **2025-12-06 新增**: 矩形区域差分帧类型 (类型 16)，优化局部UI更新场景

---

## 11. 已知问题与修复历史

### CRITICAL-001: uint16 溢出问题 (已修复)

**问题描述：**
- 2025-12-06 之前的版本中，直接差分块头的 `start_idx` 使用 uint16（最大值 65,535）
- 对于总像素数超过 65,536 的图像（如 240×426 = 102,240 像素），会发生索引溢出
- 导致差分帧解压错误率高达 12-16%

**影响范围：**
- 任何 宽度 × 高度 > 65,536 的图像
- 临界值示例：240×274 以上，256×256 以上

**修复方案：**
- 将块头的 `start_idx` 字段从 uint16 (2字节) 改为 uint32 (4字节)
- 块头大小从 4 字节增加到 6 字节
- 现在支持最大 4,294,967,295 像素的图像

**向后兼容性：**
- ⚠️ **格式不兼容** - 旧版本无法正确读取新格式文件
- 建议重新编码所有受影响的 DFA 文件

详细信息请参阅 `BUGFIX_UINT16_OVERFLOW.md`

---

## 12. 许可

本格式规范按原样提供，供教育和开发用途使用。